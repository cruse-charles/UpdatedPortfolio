<!DOCTYPE HTML>
<!--
	Future Imperfect by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title>Single - Future Imperfect by HTML5 UP</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="../assets/css/main.css" />
	<link href="https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism-okaidia.css" rel="stylesheet" />
</head>

<body class="single is-preload">

	<!-- Wrapper -->
	<div id="wrapper">

		<!-- Header -->
		<header id="header">
			<h1><a href="../index.html">Portfolio Site of Charles Cruse</a></h1>
			<nav class="links">
				<ul>
					<li><a href="../aboutme.html">About Me</a></li>
					<li><a href="../assets/Charles_Cruse_Resume.pdf">Resume</a></li>
					<!-- <li><a href="#">Projects</a></li> -->
				</ul>
			</nav>
			<!-- <nav class="main">
                <ul>
                    <li class="search">
                        <a class="fa-search" href="#search">Search</a>
                        <form id="search" method="get" action="#">
                            <input type="text" name="query" placeholder="Search" />
                        </form>
                    </li>
                    <li class="menu">
                        <a class="fa-bars" href="#menu">Menu</a>
                    </li>
                </ul>
            </nav> -->
		</header>

		<!-- Menu -->
		<section id="menu">

			<!-- Search -->
			<!-- <section>
				<form class="search" method="get" action="#">
					<input type="text" name="query" placeholder="Search" />
				</form>
			</section> -->

			<!-- Links -->
			<!-- <section>
				<ul class="links">
					<li>
						<a href="#">
							<h3>Lorem ipsum</h3>
							<p>Feugiat tempus veroeros dolor</p>
						</a>
					</li>
					<li>
						<a href="#">
							<h3>Dolor sit amet</h3>
							<p>Sed vitae justo condimentum</p>
						</a>
					</li>
					<li>
						<a href="#">
							<h3>Feugiat veroeros</h3>
							<p>Phasellus sed ultricies mi congue</p>
						</a>
					</li>
					<li>
						<a href="#">
							<h3>Etiam sed consequat</h3>
							<p>Porta lectus amet ultricies</p>
						</a>
					</li>
				</ul>
			</section> -->

			<!-- Actions -->
			<!-- <section>
				<ul class="actions stacked">
					<li><a href="#" class="button large fit">Log In</a></li>
				</ul>
			</section> -->

		</section>

		<!-- Main -->
		<div id="main">

			<!-- Post -->
			<article class="post">
				<header>
					<div class="title">
						<h2><a href="#">Building A Real App #5</a></h2>
						<p>Follow along with my journey to build a real app</p>
					</div>
					<div class="meta">
						<time class="published" datetime="2025-05-13">May 13, 2025</time>
						<!-- <a href="#" class="author"><span class="name">Jane Doe</span><img src="images/avatar.jpg"
								alt="" /></a> -->
					</div>
				</header>
				<span><img src="../images/BlogImages/Blog6/PhotoHeader.webp" alt="" /></span>
				<h2>Moving to Redux & Setting Up the Slice</h2>
				<p>
					I eventually hit the point where passing props around was getting out of hand. I had 
					components passing data to children, and then grandchildren, just so something deep in 
					the tree could update or read assignment data. None of this felt sustainable for an app 
					where multiple components need the same assignment information.
					
					<br><br>
					So I moved to Redux. This meant creating a store, a slice, and restructuring how I fetch
					and update assignment data. The nice part is that Redux Toolkit reduces a lot of
					boilerplate—I didn't have to manually write action creators, switch statements, or
					immutable update reducers. Everything lives inside a slice.
				</p>
				<h2>The Async Thunk — Finally Mixing Firebase + Redux Cleanly</h2>
				<p>
					One of the cooler moments was realizing I could fold all my Firebase-read logic directly 
					inside a Redux async thunk instead of writing:
					<ul>
						<li>one action to start loading</li>
						<li>another action for success</li>
						<li>another action for error</li>
						<li>a separate thunk file</li>
						<li>and a reducer switch statement</li>
					</ul>

					Redux Toolkit compresses that into a single createAsyncThunk:

				<pre><code class="language-tsx">
					export const fetchAssignments = createAsyncThunk(
						"studentAssignments/fetchAssignments",
						async (assignmentsDocIds: string[], {rejectWithValue}) => {
							try {
							const assignments = await Promise.all(
								assignmentsDocIds.map(async (assignmentDocId) => {
								const assignmentRef = doc(db, "assignments", assignmentDocId);
								const snapshot = await getDoc(assignmentRef);

								if (!snapshot.exists()) {
									throw new Error(`Assignment with ID ${assignmentDocId} not found`);
								}

								const data = snapshot.data();
								
								return {
									id: snapshot.id,
									title: data?.title || "",
									type: data?.type || "",
									priority: data?.priority || "",
									dueDate: data?.dueDate || undefined,
									note: data?.note || "",
									createdAt: data?.createdAt || null,
									student: data?.student || "",
									folder: data?.folder || "",
									status: data?.status || "",
									timeline: data?.timeline || [],
									...data,
								};
								})
							);

							return assignments;
							} catch (error) {
							return rejectWithValue((error as Error).message);
							}
						});
				</code></pre>
				<h2>Looking at a Few Reducers I Wrote</h2>
				<p>
					Redux Toolkit uses Immer under the hood, so I can safely “mutate” the state without
					worrying about immutability rules. Two reducers that felt especially useful:
				</p>
				<p>
					1. addEntry
					It directly manipulates the timeline array—Immer handles the immutable clone internally.
					For extending the timeline of a specific assignment:
				</p>
				<pre><code class="language-tsx">
					addEntry(state, action) {
						const { entryData, assignmentId } = action.payload;
						const index = state.findIndex(a => a.id === assignmentId);

						if (index !== -1) {
							state[index].timeline.push(entryData);
						}
					}
				</code></pre>
				<p>
					2. updateAssignmentSlice
					For partial updates (changing status, adding metadata, adjusting titles, etc.):
					Instead of replacing the entire assignment object, I merge only the updated fields.
				</p>
                <pre><code class="language-tsx">
					updateAssignmentSlice(state, action) {
						const { assignmentId, updateData } = action.payload;
						const index = state.findIndex(a => a.id === assignmentId);

						if (index !== -1) {
							state[index] = { ...state[index], ...updateData };
						}
					}
				</code></pre>
				<p>
					3. extraReducers
					What really tied everything together was extraReducers, which lets the slice respond 
					to lifecycle states of the async thunk:
				</p>
                <pre><code class="language-tsx">
					extraReducers: (builder) => {
						builder
							.addCase(fetchAssignments.fulfilled, (state, action) => {
							return action.payload;
							})
							.addCase(fetchAssignments.rejected, (state, action) => {
							console.error("fetchAssignments rejected:", action.payload);
							return state;
							})
						}
				</code></pre>
				<p>
					It also gives really explicit control:
					fulfilled = replace assignments,
					rejected = keep old state but log issue,
					pending (optional) = show loading indicator if I ever need it.

					<br><br>
					Between learning how to adapt form handling for shadcn's components and debugging browser quirks 
					with file inputs, this part of the build forced me to dig deeper into React form patterns and how 
					browser file inputs actually work under the hood.
				</p>
				<h2>Designing the Timeline Data Structure</h2>
				<p>
					The next challenge was designing a timeline of updates for each assignment. My current 
					structure only allowed one file + one note per assignment, which isn't enough for 
					revision cycles or back-and-forth feedback.
					<br><br>
					So I'm redesigning everything so each assignment becomes a single Firestore document 
					with a timeline array:

				</p>
				<h3>Assigment Doc</h3>
				<pre><code class="language-tsx">
					/assignments/{assignmentId}
					{
						title,
						description,
						dueDate,
						studentId,
						consultantId,
						status,
						createdAt,
						updatedAt,
						timeline: [ ...entries ]
					}
				</code></pre>
				<h3>Timeline Entry</h3>
				<pre><code class="language-tsx">
					{
					id,
					uploadedBy: "student" | "consultant",
					type: "file" | "note" | "both",
					file: { name, url, storagePath } | null,
					note: string | null,
					timestamp
					}
				</code></pre>
				<p>This way, I'm getting:
					<ul>
						<li>Chronological progress tracking</li>
						<li>No overwriting drafts</li>
						<li>Consultant + student can go back-and-forth naturally</li>
						<li>Fits analytics later (revision counts, time between drafts, etc.)</li>
					</ul>
				</p>
				<h2>What I Learned</h2>
				<p>
					<p>This whole process from prop-drilling to Redux, integrating Firebase queries inside async thunks, 
						designing reducers with Immer, and redefining the entire assignment data structure—felt like 
						the first time I've really considered the architecture of an app!
					</p>
					<ul>
						<li>
							Async thunks provide a clean way to handle Firebase reads/writes while keeping
							components focused on UI only.
						</li>
						<li>
							Immer (built into Redux ToolKit) makes reducers easy to write without worrying
							about manual immutability.
							</li>
						<li>
							extraReducers give clear pending/fulfilled/rejected states, which really speeds 
							up the debugging process when errors come up.
						</li>
					</ul>
				</p>
				<h2>What's Next</h2>
				<p>
					I'll be moving onto transitioning this app into the initial stages of being product-ready.
					This means I need to set up proper security rules and clean up my file structure.
					<ul>
						<li>
							Update Firebase security rules now that development mode is over.
						</li>
						<li>
							Refactor file and folder names across the project using a clear verb-object 
							naming pattern since all my files are getting hard to organize.
						</li>
						<li>
							Reorganize directory structure to make files discoverable and maintainable.
						</li>
						<li>
							Continue reducing prop drilling by adding Redux.
						</li>
					</ul>
				</p>
				<footer>
					<!-- <ul class="stats">
						<li><a href="#">General</a></li>
						<li><a href="#" class="icon solid fa-heart">28</a></li>
						<li><a href="#" class="icon solid fa-comment">128</a></li>
					</ul> -->
				</footer>
			</article>

		</div>

		<!-- Footer -->
		<section id="footer">
			<ul class="icons">
				<li><a href="https://www.linkedin.com/in/charles-cruse-2ba72ab6/"
						class="icon brands fa-linkedin fa-lg"><span class="label">LinkedIn</span></a></li>
				<li><a href="https://github.com/cruse-charles" class="icon brands fa-github fa-lg"><span
							class="label">Github</span></a></li>
				<li><a href="mailto:charlesncruse@gmail.com" class="icon solid fa-envelope fa-lg"><span
							class="label">Email</span></a></li>
			</ul>
			<p class="copyright">&copy; Untitled. Design: <a href="http://html5up.net">HTML5 UP</a>.
		</section>

	</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js"></script>

</body>

</html>